/**
 * slang - a simple scripting language.
 *
 * code generation.
 *
 * \author Felix Lubbe
 * \copyright Copyright (c) 2024
 * \license Distributed under the MIT software license (see accompanying LICENSE.txt).
 */

#pragma once

#include <stdexcept>
#include <list>
#include <string>
#include <vector>

#include <fmt/core.h>

#include "archives/archive.h"
#include "archives/memory.h"

/* Forward declarations. */
namespace slang
{
struct token_location;                 /* token.h */
enum class symbol_type : std::uint8_t; /* module.h */
class language_module;                 /* module.h */
class instruction_emitter;             /* emitter.h */
}    // namespace slang

namespace slang::codegen
{

/** A code generation error. */
class codegen_error : public std::runtime_error
{
public:
    /**
     * Construct a `codegen_error`.
     *
     * @note Use the other constructor if you want to include location information in the error message.
     *
     * @param message The error message.
     */
    codegen_error(const std::string& message)
    : std::runtime_error{message}
    {
    }

    /**
     * Construct a `codegen_error`.
     *
     * @param loc The error location in the source.
     * @param message The error message.
     */
    codegen_error(const slang::token_location& loc, const std::string& message);
};

/**
 * A value. Values can be generated by evaluating an expression.
 */
class value
{
    /** The value's type. Can be one of: i32, f32, str, addr, ptr, aggregate. */
    std::string type;

    /** Aggregate type name. Only valid if type is "aggregate". */
    std::optional<std::string> aggregate_type;

    /** An optional name for the value. */
    std::optional<std::string> name;

protected:
    /**
     * Validate the value.
     *
     * @throws A `codegen_error` if the pair (type, aggregate_type) is invalid.
     */
    void validate() const
    {
        bool is_builtin = (type == "void") || (type == "i32") || (type == "f32") || (type == "str") || (type == "fn");
        bool is_ref = (type == "addr") || (type == "ptr");
        if(is_builtin || is_ref)
        {
            if(aggregate_type.has_value())
            {
                throw codegen_error("Aggregate type cannot contain value for built-in types.");
            }

            return;
        }

        if(type != "aggregate")
        {
            throw codegen_error(fmt::format("Invalid value type '{}'.", type));
        }

        if(!aggregate_type.has_value() || aggregate_type->length() == 0)
        {
            throw codegen_error("Empty aggregate type.");
        }

        is_builtin = (*aggregate_type == "i32") || (*aggregate_type == "f32") || (*aggregate_type == "str");
        if(is_builtin)
        {
            throw codegen_error(fmt::format("Aggregate type cannot have the same name '{}' as a built-in type.", *aggregate_type));
        }
    }

public:
    /** Default constructors. */
    value() = default;
    value(const value&) = default;
    value(value&&) = default;

    /** Default assignments. */
    value& operator=(const value&) = default;
    value& operator=(value&&) = default;

    /**
     * Construct a value.
     *
     * @param type The value type.
     * @param aggregate_type Type name for aggregate types.
     * @param name Optional name for this value.
     */
    value(std::string type, std::optional<std::string> aggregate_type = std::nullopt, std::optional<std::string> name = std::nullopt)
    : type{std::move(type)}
    , aggregate_type{std::move(aggregate_type)}
    , name{std::move(name)}
    {
        validate();
    }

    /**
     * Copy the type into a new value.
     */
    value copy_type() const
    {
        return {type, aggregate_type, std::nullopt};
    }

    /**
     * Get the value as a readable string.
     */
    std::string to_string() const
    {
        if(has_name())
        {
            return fmt::format("{} %{}", is_aggregate() ? get_aggregate_type() : get_type(), *get_name());
        }

        return fmt::format("{}", is_aggregate() ? get_aggregate_type() : get_type());
    }

    /** Get the value's type. */
    std::string get_type() const
    {
        return type;
    }

    /** Return whether this value has an aggregate type. */
    bool is_aggregate() const
    {
        return type == "aggregate";
    }

    /**
     * Get the value's aggregate type.
     *
     * @throws A `codegen_error` if called on non-aggregate type.
     */
    std::string get_aggregate_type() const
    {
        if(!is_aggregate())
        {
            throw codegen_error(fmt::format("Cannot get aggregate type for '{}', as it is not aggregate.", type));
        }

        return *aggregate_type;
    }

    /** Get the value's type, also resolving aggregate types. */
    std::string get_resolved_type() const
    {
        if(is_aggregate())
        {
            return get_aggregate_type();
        }

        return get_type();
    }

    /** Set the value's name. */
    void set_name(std::string name)
    {
        this->name = std::move(name);
    }

    /** Get the value's name. */
    std::optional<std::string> get_name() const
    {
        return name;
    }

    /** Delete the value's name. */
    void delete_name()
    {
        name = std::nullopt;
    }

    /** Return whether the value has a name. */
    bool has_name() const
    {
        return name != std::nullopt;
    }
};

/**
 * A constant integer value.
 */
class constant_int : public value
{
    /** The integer. */
    int i;

public:
    /** Default constructors. */
    constant_int() = default;
    constant_int(const constant_int&) = default;
    constant_int(constant_int&&) = default;

    /** Default assignments. */
    constant_int& operator=(const constant_int&) = default;
    constant_int& operator=(constant_int&&) = default;

    /**
     * Construct a constant integer.
     *
     * @param i The integer.
     * @param name An optional name.
     */
    constant_int(int i, std::optional<std::string> name = std::nullopt)
    : value{"i32", std::nullopt, std::move(name)}
    , i{i}
    {
    }

    /** Get the integer. */
    int get_int() const
    {
        return i;
    }
};

/**
 * A constant floating point value.
 */
class constant_float : public value
{
    /** The floating point value. */
    float f;

public:
    /** Default constructors. */
    constant_float() = default;
    constant_float(const constant_float&) = default;
    constant_float(constant_float&&) = default;

    /** Default assignments. */
    constant_float& operator=(const constant_float&) = default;
    constant_float& operator=(constant_float&&) = default;

    /**
     * Construct a constant floating point value.
     *
     * @param f The floating point value.
     * @param name An optional name.
     */
    constant_float(float f, std::optional<std::string> name = std::nullopt)
    : value{"f32", std::nullopt, std::move(name)}
    , f{f}
    {
    }

    /** Get the floating point value. */
    float get_float() const
    {
        return f;
    }
};

/**
 * A constant string value.
 */
class constant_str : public value
{
    /** The string. */
    std::string s;

    /** Index into the string table. */
    int constant_index{-1};

public:
    /** Default constructors. */
    constant_str() = default;
    constant_str(const constant_str&) = default;
    constant_str(constant_str&&) = default;

    /** Default assignments. */
    constant_str& operator=(const constant_str&) = default;
    constant_str& operator=(constant_str&&) = default;

    /**
     * Construct a constant string value.
     *
     * @param s The string.
     * @param name An optional name.
     */
    constant_str(std::string s, std::optional<std::string> name = std::nullopt)
    : value{"str", std::nullopt, std::move(name)}
    , s{std::move(s)}
    {
    }

    /** Get the string value. */
    std::string get_str() const
    {
        return s;
    }

    /**
     * Set the index into the string table.
     *
     * @param index The new index. A index of -1 means "no index".
     *              Must be non-negative or -1.
     */
    void set_constant_index(int index)
    {
        if(index < -1)
        {
            throw codegen_error(fmt::format("String index must be non-negative or -1. Got {}.", index));
        }

        constant_index = index;
    }

    /** Get the index into the string table. A value of -1 indicates "no index". */
    int get_constant_index() const
    {
        return constant_index;
    }
};

/**
 * An instruction argument.
 */
class argument
{
public:
    /** Default constructors. */
    argument() = default;
    argument(const argument&) = default;
    argument(argument&&) = default;

    /** Destructor. */
    virtual ~argument() = default;

    /** Default assignment. */
    argument& operator=(const argument&) = default;
    argument& operator=(argument&&) = default;

    /** Register this argument in the constant table, if necessary. */
    virtual void register_const(class context& ctx)
    {
    }

    /** Get a string representation of the argument. */
    virtual std::string to_string() const = 0;

    /** Get the argument type. */
    virtual const value* get_value() const = 0;
};

/**
 * A constant instruction argument.
 */
class const_argument : public argument
{
    /** The constant type. */
    std::unique_ptr<value> type;

public:
    /** Default and delered constructors. */
    const_argument() = default;
    const_argument(const const_argument&) = delete;
    const_argument(const_argument&&) = default;

    /** Default and deleted assignments. */
    const_argument& operator=(const const_argument&) = delete;
    const_argument& operator=(const_argument&&) = default;

    /**
     * Create an integer argument.
     *
     * @param i The constant integer.
     */
    const_argument(int i)
    : argument()
    , type{std::make_unique<constant_int>(i)}
    {
    }

    /**
     * Create a floating-point argument.
     *
     * @param f The floating-point value.
     */
    const_argument(float f)
    : argument()
    , type{std::make_unique<constant_float>(f)}
    {
    }

    /**
     * Create a string argument.
     *
     * @note A string needs to be registered with a context using `register_const`.
     *
     * @param s The string.
     */
    const_argument(std::string s)
    : argument()
    , type{std::make_unique<constant_str>(s)}
    {
    }

    void register_const(class context& ctx) override;

    std::string to_string() const override
    {
        std::string type_name = type->get_resolved_type();

        if(type_name == "i32")
        {
            return fmt::format("i32 {}", static_cast<constant_int*>(type.get())->get_int());
        }
        else if(type_name == "f32")
        {
            return fmt::format("f32 {}", static_cast<constant_float*>(type.get())->get_float());
        }
        else if(type_name == "str")
        {
            return fmt::format("str @{}", static_cast<constant_str*>(type.get())->get_constant_index());
        }

        throw codegen_error(fmt::format("Unrecognized const_argument type."));
    }

    const slang::codegen::value* get_value() const override
    {
        return type.get();
    }
};

/**
 * Function argument.
 */
class function_argument : public argument
{
    /** The function's name. */
    std::unique_ptr<value> name;

public:
    /** Default and deleted constructors. */
    function_argument() = default;
    function_argument(const function_argument&) = delete;
    function_argument(function_argument&&) = default;

    /** Defaulted and deleted assignments. */
    function_argument& operator=(const function_argument&) = delete;
    function_argument& operator=(function_argument&&) = default;

    /**
     * Create a function argument.
     *
     * @param name The function name.
     */
    function_argument(std::string name)
    : argument()
    , name{std::make_unique<value>("fn", std::nullopt, std::move(name))}
    {
    }

    std::string to_string() const override
    {
        return fmt::format("@{}", *name->get_name());
    }

    const slang::codegen::value* get_value() const override
    {
        return name.get();
    }
};

/**
 * Type argument.
 */
class type_argument : public argument
{
    /** The type. */
    value vt;

public:
    /** Default constructors. */
    type_argument() = default;
    type_argument(const type_argument&) = default;
    type_argument(type_argument&&) = default;

    /** Default assignments. */
    type_argument& operator=(const type_argument&) = default;
    type_argument& operator=(type_argument&&) = default;

    /**
     * Create a type argument.
     *
     * @param v Value containing the type information to use.
     */
    type_argument(value vt)
    : argument()
    , vt{vt.copy_type()}
    {
    }

    std::string to_string() const override
    {
        return vt.to_string();
    }

    const value* get_value() const override
    {
        return &vt;
    }
};

/**
 * A variable instruction argument.
 */
class variable_argument : public argument
{
    /** The variable. */
    value var;

public:
    /** Default constructors. */
    variable_argument() = default;
    variable_argument(const variable_argument&) = default;
    variable_argument(variable_argument&&) = default;

    /** Default assignments. */
    variable_argument& operator=(const variable_argument&) = default;
    variable_argument& operator=(variable_argument&&) = default;

    /**
     * Create a variable argument.
     *
     * @param v The variable.
     */
    variable_argument(value v)
    : argument()
    , var{std::move(v)}
    {
    }

    std::string to_string() const override
    {
        return fmt::format("{}", var.to_string());
    }

    const value* get_value() const override
    {
        return &var;
    }
};

/**
 * A label argument for jump instructions.
 */
class label_argument : public argument
{
    /** The label. */
    std::string label;

public:
    /** Default constructors. */
    label_argument() = default;
    label_argument(const label_argument&) = default;
    label_argument(label_argument&&) = default;

    /** Default assignments. */
    label_argument& operator=(const label_argument&) = default;
    label_argument& operator=(label_argument&&) = default;

    /**
     * Construct a label.
     *
     * @param label The label.
     */
    label_argument(std::string label)
    : argument()
    , label{std::move(label)}
    {
    }

    std::string to_string() const override
    {
        return fmt::format("%{}", label);
    }

    value* get_value() const override
    {
        throw codegen_error(fmt::format("Cannot get type from label '{}'.", to_string()));
    }
};

/**
 * Instruction base class.
 */
class instruction
{
    /** The instruction name. */
    std::string name;

    /** The instruction's arguments. */
    std::vector<std::unique_ptr<argument>> args;

public:
    /** Default constructors. */
    instruction() = default;
    instruction(const instruction&) = default;
    instruction(instruction&&) = default;

    /** Destructor. */
    virtual ~instruction() = default;

    /** Default assignments. */
    instruction& operator=(const instruction&) = default;
    instruction& operator=(instruction&&) = default;

    /**
     * Construct an instruction without arguments.
     *
     * @param name The instruction's opcode name.
     */
    instruction(std::string name)
    : name{std::move(name)}
    {
    }

    /**
     * Construct an instruction with arguments.
     *
     * @param name The instruction's opcode name.
     * @param args The instruction's arguments.
     */
    instruction(std::string name, std::vector<std::unique_ptr<argument>> args)
    : name{std::move(name)}
    , args{std::move(args)}
    {
    }

    /** Returns whether the instruction is branching. */
    virtual bool is_branching() const
    {
        return name == "jmp" || name == "ifeq";
    }

    /** Returns whether the instruction is a return instruction. */
    virtual bool is_return() const
    {
        return name == "ret";
    }

    /** Get the instruction name. */
    const std::string& get_name() const
    {
        return name;
    }

    /** Get the instruction's arguments. */
    const std::vector<std::unique_ptr<argument>>& get_args() const
    {
        return args;
    }

    /** Get instruction representation as string. */
    std::string to_string() const
    {
        std::string buf;
        if(args.size() > 0)
        {
            buf = " ";
            for(std::size_t i = 0; i < args.size() - 1; ++i)
            {
                buf += args[i]->to_string() + ", ";
            }
            buf += args.back()->to_string();
        }
        return fmt::format("{}{}", name, buf);
    }
};

/**
 * A block that has a single named entry point, a single exit point and
 * no branching.
 */
class basic_block
{
    friend class context;

    /** The block's entry label. */
    std::string label;

    /** The instructions. */
    std::vector<std::unique_ptr<instruction>> instrs;

    /** The associated inserting context (if any). */
    class context* inserting_context{nullptr};

    /**
     * Set a new context for inserting instructions.
     * Pass nullptr to clear the context.
     *
     * @param ctx The new context or nullptr.
     */
    void set_inserting_context(class context* ctx);

public:
    /** Default constructors. */
    basic_block() = default;
    basic_block(const basic_block&) = default;
    basic_block(basic_block&&) = default;

    /** Destructor. */
    virtual ~basic_block()
    {
        // clear references to this block.
        set_inserting_context(nullptr);
    }

    /** Default assignments. */
    basic_block& operator=(const basic_block&) = default;
    basic_block& operator=(basic_block&&) = default;

    /**
     * Create a basic_block.
     *
     * @param label The block's label.
     */
    basic_block(std::string label)
    : label{std::move(label)}
    {
    }

    /**
     * Add a non-branching instruction.
     *
     * Throws a `codegen_error` if the instruction is branching.
     *
     * @param instr The instruction.
     */
    void add_instruction(std::unique_ptr<instruction> instr)
    {
        instrs.emplace_back(std::move(instr));
    }

    /** Get string representation of block. */
    std::string to_string() const
    {
        if(instrs.size() == 0)
        {
            return fmt::format("{}:", label);
        }

        std::string buf = fmt::format("{}:\n", label);
        for(std::size_t i = 0; i < instrs.size() - 1; ++i)
        {
            buf += fmt::format(" {}\n", instrs[i]->to_string());
        }
        buf += fmt::format(" {}", instrs.back()->to_string());
        return buf;
    }

    /** Get the inserting context. May return nullptr. */
    class context* get_inserting_context() const
    {
        return inserting_context;
    }

    /** Get the block label. */
    std::string get_label() const
    {
        return label;
    }

    /** Return whether this block ends with a return statement. */
    bool ends_with_return() const
    {
        return instrs.size() > 0 && instrs.back()->is_return();
    }

    /**
     * Return whether this block is valid.
     *
     * A block is valid if it contains a single return or branch instruction,
     * located at its end.
     */
    bool is_valid() const
    {
        std::size_t branch_return_count = 0;
        bool last_instruction_branch_return = false;
        for(auto& it: instrs)
        {
            last_instruction_branch_return = it->is_branching() || it->is_return();
            if(last_instruction_branch_return)
            {
                branch_return_count += 1;
            }
        }
        return branch_return_count == 1 && last_instruction_branch_return;
    }

    /** Get the block's instructions. */
    const std::vector<std::unique_ptr<instruction>>& get_instructions() const
    {
        return instrs;
    }

    /** Get the block's instructions. */
    std::vector<std::unique_ptr<instruction>>& get_instructions()
    {
        return instrs;
    }
};

/**
 * A scope has a name and holds variables.
 */
class scope
{
    /** The scope's name. */
    std::string name;

    /** Reference to the outer scope (if any). */
    scope* outer{nullptr};

    /** Arguments for function scopes. */
    std::vector<std::unique_ptr<value>> args;

    /** Variables inside the scope. */
    std::vector<std::unique_ptr<value>> locals;

public:
    /** Constructors. */
    scope() = default;
    scope(const scope&) = delete;
    scope(scope&&) = default;

    /** Destructor. */
    virtual ~scope() = default;

    /** Assignments. */
    scope& operator=(const scope&) = delete;
    scope& operator=(scope&&) = default;

    /**
     * Create a scope from a name (e.g. "<global>").
     *
     * @param name The scope's name.
     */
    scope(std::string name)
    : name{std::move(name)}
    {
    }

    /**
     * Create a scope and initialize it with function arguments.
     *
     * @param name The scope's name (usually the same as the function's name)
     * @param args The function's arguments.
     */
    scope(std::string name, std::vector<std::unique_ptr<value>> args)
    : name{std::move(name)}
    , args{std::move(args)}
    {
    }

    /**
     * Check if the name is already contained in this scope as an argument or a local variable.
     *
     * @returns True if the name exists.
     * @throws Throws a `codegen_error` if an unnamed value is found within the scope.
     */
    bool contains(const std::string& name) const
    {
        if(std::find_if(args.begin(), args.end(),
                        [&name](const std::unique_ptr<value>& v) -> bool
                        {
                            if(!v->has_name())
                            {
                                throw codegen_error("Scope contains unnamed value.");
                            }

                            return *v->get_name() == name;
                        })
           != args.end())
        {
            return true;
        }

        if(std::find_if(locals.begin(), locals.end(),
                        [&name](const std::unique_ptr<value>& v) -> bool
                        {
                            if(!v->has_name())
                            {
                                throw codegen_error("Scope contains unnamed value.");
                            }

                            return *v->get_name() == name;
                        })
           != locals.end())
        {
            return true;
        }

        return false;
    }

    /**
     * Get the variable for the given name.
     *
     * @param name The variable's name.
     * @returns The variable or nullptr.
     * @throws Throws a `codegen_error` if an unnamed value is found within the scope.
     */
    value* get_value(const std::string& name)
    {
        auto it = std::find_if(args.begin(), args.end(),
                               [&name](const std::unique_ptr<value>& v) -> bool
                               {
                                   if(!v->has_name())
                                   {
                                       throw codegen_error("Scope contains unnamed value.");
                                   }

                                   return *v->get_name() == name;
                               });
        if(it != args.end())
        {
            return it->get();
        }

        it = std::find_if(locals.begin(), locals.end(),
                          [&name](const std::unique_ptr<value>& v) -> bool
                          {
                              if(!v->has_name())
                              {
                                  throw codegen_error("Scope contains unnamed value.");
                              }

                              return *v->get_name() == name;
                          });

        if(it != locals.end())
        {
            return it->get();
        }

        return nullptr;
    }

    /**
     * Get the index on argument or a local. Indices are with respect to
     * the list `[arg1, ... argN, local1, ... localM]`.
     *
     * Indices are not constant during code generation. They are constant
     * during instruction emission.
     *
     * @param name Name or the local or the argument.
     * @throws A `codegen_error` the the name could not be found.
     */
    std::size_t get_index(const std::string& name) const
    {
        auto it = std::find_if(args.begin(), args.end(),
                               [&name](const std::unique_ptr<value>& v) -> bool
                               {
                                   if(!v->has_name())
                                   {
                                       throw codegen_error("Scope contains unnamed value.");
                                   }

                                   return *v->get_name() == name;
                               });
        if(it != args.end())
        {
            return it - args.begin();
        }

        it = std::find_if(locals.begin(), locals.end(),
                          [&name](const std::unique_ptr<value>& v) -> bool
                          {
                              if(!v->has_name())
                              {
                                  throw codegen_error("Scope contains unnamed value.");
                              }

                              return *v->get_name() == name;
                          });

        if(it != locals.end())
        {
            return args.size() + (it - locals.begin());
        }

        throw codegen_error(fmt::format("Name '{}' not found in scope.", name));
    }

    /**
     * Add an argument.
     *
     * @param arg The argument.
     * @throws Throws a `codegen_error` if the supplied argument has no name or if the
     *         scope already has an object with the same name.
     */
    void add_argument(std::unique_ptr<value> arg)
    {
        if(!arg->has_name())
        {
            throw codegen_error("Cannot add unnamed argument to scope.");
        }

        if(contains(*arg->get_name()))
        {
            throw codegen_error(fmt::format("Name '{}' already contained in scope.", *arg->get_name()));
        }
        args.emplace_back(std::move(arg));
    }

    /**
     * Add a local variable.
     *
     * @param arg The variable.
     * @throws Throws a `codegen_error` if the supplied local has no name or if the
     *         scope already has an object with the same name.
     */
    void add_local(std::unique_ptr<value> arg)
    {
        if(!arg->has_name())
        {
            throw codegen_error("Cannot add unnamed argument to scope.");
        }

        if(contains(*arg->get_name()))
        {
            throw codegen_error(fmt::format("Name '{}' already contained in scope.", *arg->get_name()));
        }
        locals.emplace_back(std::move(arg));
    }

    /** Get the arguments for this scope. */
    const std::vector<std::unique_ptr<value>>& get_args() const
    {
        return args;
    }

    /** Get the locals for this scope. */
    const std::vector<std::unique_ptr<value>>& get_locals() const
    {
        return locals;
    }

    /** Get the outer scope. */
    scope* get_outer()
    {
        return outer;
    }

    /** Get the outer scope. */
    const scope* get_outer() const
    {
        return outer;
    }

    /** Get a string representation of the scope. */
    std::string to_string() const
    {
        if(outer)
        {
            return fmt::format("{}::{}", outer->to_string(), name);
        }

        return name;
    }
};

/**
 * A scope guard that automatically gets called when the scope is exited.
 */
class scope_guard
{
    /** The associated context. */
    context& ctx;

    /** The scope. */
    scope* s;

public:
    /** No default constructor. */
    scope_guard() = delete;

    /** Default copy and move constructors. */
    scope_guard(const scope_guard&) = default;
    scope_guard(scope_guard&&) = default;

    /**
     * Construct a scope guard.
     *
     * @param ctx The associated context.
     * @param s The scope.
     */
    scope_guard(context& ctx, scope* s);

    /** Destructor. */
    ~scope_guard();

    /** Default assignments.*/
    scope_guard& operator=(const scope_guard&) = delete;
    scope_guard& operator=(scope_guard&&) = delete;
};

/**
 * Function prototype information.
 */
class prototype
{
    /** The function's name. */
    std::string name;

    /** The return type of the function. */
    std::string return_type;

    /** The argument types. */
    std::vector<value> arg_types;

    /** The module path for imported functions and std::nullopt for prototypes within the current module. */
    std::optional<std::string> import_path;

public:
    /** Default constructors. */
    prototype() = default;
    prototype(const prototype&) = default;
    prototype(prototype&&) = default;

    /** Default assignments. */
    prototype& operator=(const prototype&) = default;
    prototype& operator=(prototype&&) = default;

    /**
     * Construct a function prototype.
     *
     * @param name The function's name.
     * @param return_type The function's return type.
     * @param arg_type The function's argument types.
     * @param import_path The import path of the module for imported functions.
     */
    prototype(std::string name, std::string return_type, std::vector<value> arg_types, std::optional<std::string> import_path = std::nullopt)
    : name{std::move(name)}
    , return_type{std::move(return_type)}
    , arg_types{std::move(arg_types)}
    , import_path{std::move(import_path)}
    {
    }

    /** Get the function's name. */
    const std::string& get_name() const
    {
        return name;
    }

    /** Get the function's return type. */
    const std::string& get_return_type() const
    {
        return return_type;
    }

    /** Get the function's argument types. */
    const std::vector<value>& get_arg_types() const
    {
        return arg_types;
    }

    /** Return whether this is an imported function. */
    bool is_import() const
    {
        return import_path.has_value();
    }

    /** Return the import path. */
    const std::optional<std::string>& get_import_path() const
    {
        return import_path;
    }
};

/**
 * A relocatable function.
 */
class function
{
    /** The function's name. */
    std::string name;

    /** Whether this is a native function. */
    bool native;

    /** Import library name for native functions. */
    std::string import_library;

    /** The function's return type. */
    std::string return_type;

    /** The function variable scope. */
    scope scope;

    /** Function instructions. */
    std::list<basic_block> instr_blocks;

public:
    /** Constructors. */
    function() = default;
    function(const function&) = delete;
    function(function&&) = default;

    /**
     * Construct a function from name, return type and argument list.
     *
     * @param name The function's name.
     * @param return_type The function's return type.
     * @param args The function's argument list.
     */
    function(std::string name, std::string return_type, std::vector<std::unique_ptr<value>> args)
    : name{name}
    , native{false}
    , return_type{std::move(return_type)}
    , scope{std::move(name), std::move(args)}
    {
    }

    /**
     * Construct a native function from import library name and function name.
     *
     * @param import_library The import library's name.
     * @param name The function's name.
     * @param return_type The function's return type.
     * @param args The function's argument list.
     */
    function(std::string import_library, std::string name, std::string return_type, std::vector<std::unique_ptr<value>> args)
    : name{name}
    , native{true}
    , import_library{import_library}
    , return_type{std::move(return_type)}
    , scope{std::move(name), std::move(args)}
    {
    }

    /** Destructor. */
    virtual ~function() = default;

    /** Assignments. */
    function& operator=(const function&) = delete;
    function& operator=(function&&) = default;

    /** Get the function's name. */
    const std::string& get_name() const
    {
        return name;
    }

    /** Get the instruction block. */
    basic_block* create_basic_block(std::string name)
    {
        instr_blocks.emplace_back(std::move(name));
        return &instr_blocks.back();
    }

    /** Create a local variable. */
    void create_local(std::unique_ptr<value> v)
    {
        scope.add_local(std::move(v));
    }

    /** Get the function's scope. */
    class scope* get_scope()
    {
        return &scope;
    }

    /** Get the function's scope. */
    const class scope* get_scope() const
    {
        return &scope;
    }

    /** Returns the function's signature as a pair (return_type, arg_types). */
    std::pair<std::string, std::vector<std::string>> get_signature() const
    {
        std::vector<std::string> arg_types;
        auto& args = scope.get_args();
        std::transform(args.cbegin(), args.cend(), std::back_inserter(arg_types),
                       [](const auto& arg)
                       {
                           return arg->get_resolved_type();
                       });
        return std::make_pair<std::string, std::vector<std::string>>(std::string{return_type}, std::move(arg_types));
    }

    /** Return whether this is a native function. */
    bool is_native() const
    {
        return native;
    }

    /**
     * Return the import library for a native function.
     *
     * @throws Throws a `codegen_error` if this is not a native function.
     *
     * @returns The import library name.
     */
    std::string get_import_library() const
    {
        if(!native)
        {
            throw codegen_error(fmt::format("Cannot get import library for function '{}', as it was not declared as native.", get_name()));
        }

        return import_library;
    }

    /**
     * Return the basic blocks.
     *
     * @returns The function's basic blocks.
     */
    const std::list<basic_block>& get_basic_blocks() const
    {
        return instr_blocks;
    }

    /** String representation of function. */
    std::string to_string() const
    {
        std::string buf;
        if(native)
        {
            buf = fmt::format("native ({}) {} @{}(", import_library, return_type, name);
        }
        else
        {
            buf = fmt::format("define {} @{}(", return_type, name);
        }

        const auto& args = scope.get_args();
        if(args.size() > 0)
        {
            for(std::size_t i = 0; i < args.size() - 1; ++i)
            {
                buf += fmt::format("{}, ", args[i]->to_string());
            }
            buf += fmt::format("{})", args.back()->to_string());
        }
        else
        {
            buf += ")";
        }

        if(!native)
        {
            buf += " {\n";
            for(auto& v: scope.get_locals())
            {
                buf += fmt::format("local {}\n", v->to_string());
            }
            for(auto& b: instr_blocks)
            {
                buf += fmt::format("{}\n", b.to_string());
            }
            buf += "}";
        }

        return buf;
    }
};

/**
 * A user-defined type.
 */
class type
{
    /** The type's name. */
    std::string name;

    /** The type's members as pairs (type_name, member_name). */
    std::vector<std::pair<std::string, std::string>> members;

public:
    /** Default constructors. */
    type() = default;
    type(const type&) = default;
    type(type&&) = default;

    /** Destructor. */
    virtual ~type() = default;

    /** Default assignment. */
    type& operator=(const type&) = default;
    type& operator=(type&&) = default;

    /**
     * Construct a new type.
     *
     * @param name The type's name.
     * @param members The type's members.
     */
    type(std::string name, std::vector<std::pair<std::string, std::string>> members)
    : name{std::move(name)}
    , members{std::move(members)}
    {
    }

    /** Get the type's name. */
    std::string get_name() const
    {
        return name;
    }

    /** String representation of a type. */
    std::string to_string() const
    {
        std::string buf = fmt::format("%{} = type {{\n", name);
        if(members.size() > 0)
        {
            for(std::size_t i = 0; i < members.size() - 1; ++i)
            {
                buf += fmt::format(" {} %{},\n", members[i].second, members[i].first);
            }
            buf += fmt::format(" {} %{},\n", members.back().second, members.back().first);
        }
        buf += "}";
        return buf;
    }
};

/**
 * A binary operation. Reads two alike values from the stack and puts a value of the same type onto the stack.
 */
enum class binary_op
{
    op_mul,           /** a * b */
    op_div,           /** a / b */
    op_mod,           /** a % b */
    op_add,           /** a + b */
    op_sub,           /** a - b */
    op_shl,           /** a << b */
    op_shr,           /** a >> b */
    op_less,          /** a < b */
    op_less_equal,    /** a <= b */
    op_greater,       /** a > b */
    op_greater_equal, /** a >= b */
    op_equal,         /** a == b */
    op_not_equal,     /** a != b */
    op_and,           /** a & b */
    op_xor,           /** a ^ b */
    op_or,            /** a | b*/
    op_logical_and,   /** a && b */
    op_logical_or,    /** a || b */
};

/**
 * Return a string representation of a binary operator.
 *
 * @param op The binary operator.
 * @returns A string representation of the operator.
 */
std::string to_string(binary_op op);

/** An imported symbol. */
struct imported_symbol
{
    /** Symbol type. */
    symbol_type type;

    /** Symbol name. */
    std::string name;

    /** The import path of the module. */
    std::string import_path;

    /** Default constructors. */
    imported_symbol() = default;
    imported_symbol(const imported_symbol&) = default;
    imported_symbol(imported_symbol&&) = default;

    /** Default assignments. */
    imported_symbol& operator=(const imported_symbol&) = default;
    imported_symbol& operator=(imported_symbol&&) = default;

    /**
     * Construct an `imported_symbol`.
     *
     * @param type The symbol's type.
     * @param name The symbol's name.
     * @param import_path Path of the module the symbol is imported from.
     */
    imported_symbol(symbol_type type, std::string name, std::string import_path)
    : type{type}
    , name{std::move(name)}
    , import_path{std::move(import_path)}
    {
    }
};

/** Code generator context. */
class context
{
    friend class slang::instruction_emitter;

    /** List of types. */
    std::vector<std::unique_ptr<type>> types;

    /** String table. */
    std::vector<std::string> strings;

    /** Global scope. */
    std::unique_ptr<scope> global_scope{std::make_unique<scope>("<global>")};

    /** The current scope stack. */
    std::vector<scope*> current_scopes;

    /** List of function prototypes. */
    std::vector<std::unique_ptr<prototype>> prototypes;

    /** List of functions. */
    std::vector<std::unique_ptr<function>> funcs;

    /** Imported symbols. */
    std::vector<imported_symbol> imports;

    /** Current instruction insertion point. */
    basic_block* insertion_point{nullptr};

protected:
    /**
     * Check that the insertion point is not null.
     *
     * @throws Throws a `codegen_error` if the insertion point is null.
     */
    void validate_insertion_point() const
    {
        if(!insertion_point)
        {
            throw codegen_error("Invalid insertion point (nullptr).");
        }
    }

public:
    /** Constructors. */
    context() = default;
    context(const context&) = delete;
    context(context&&) = default;

    /** Destructor. */
    virtual ~context()
    {
        set_insertion_point(nullptr);
    }

    /** Assignments. */
    context& operator=(const context&) = delete;
    context& operator=(context&&) = default;

    /**
     * Get the import index of a symbol. If the symbol is not found in the imports,
     * it is added.
     *
     * @param type The symbol type.
     * @param import_path Path of the module that exports the symbol.
     * @param name The symbol's name.
     * @return The symbol's index in the import table.
     */
    std::size_t get_import_index(symbol_type type, std::string import_path, std::string name);

    /**
     * Create a type.
     *
     * Throws a `codegen_error` if the type already exists or if it contains undefined types.
     *
     * @param name The type's name.
     * @returns A representation of the created type.
     */
    type* create_type(std::string name, std::vector<std::pair<std::string, std::string>> members);

    /**
     * Get a reference to a string or create a new one if it does not exist.
     *
     * @param str The string.
     * @returns An index into the string table.
     */
    std::size_t get_string(std::string str);

    /**
     * Add a function prototype.
     *
     * Throws a `codegen_error` if the prototype already exists.
     *
     * @param name The function's name.
     * @param return_type The function's return type.
     * @param args The function's arguments.
     * @param import_path The import path for the prototype.
     * @returns A representation of the prototype.
     */
    prototype* add_prototype(std::string name, std::string return_type, std::vector<value> args, std::optional<std::string> import_path = std::nullopt);

    /**
     * Get a function's prototype.
     *
     * Throws a `codegen_error` if the prototype is not found.
     *
     * @param name The function's name.
     */
    const prototype& get_prototype(const std::string& name) const;

    /**
     * Add a function definition.
     *
     * Throws a `codegen_error` if the function name already exists.
     *
     * @param name The function's name.
     * @param return_type The function's return type.
     * @param args The function's arguments.
     * @returns A representation of the function.
     */
    function* create_function(std::string name, std::string return_type, std::vector<std::unique_ptr<value>> args);

    /**
     * Add a function with a native implementation in a library.
     *
     * Throws a `codegen_error` if the function name already exists.
     *
     * @param lib_name Name of the library the function should be imported from.
     * @param name The function's name.
     * @param return_type The function's return type.
     * @param args The function's arguments.
     */
    void create_native_function(std::string lib_name, std::string name, std::string return_type, std::vector<std::unique_ptr<value>> arg);

    /**
     * Set instruction insertion point.
     *
     * @param ip The insertion point for instructions.
     */
    void set_insertion_point(basic_block* ip);

    /** Get the current insertion point. */
    basic_block* get_insertion_point() const
    {
        return insertion_point;
    }

    /**
     * Enter a new scope.
     *
     * @param s The new scope.
     */
    void enter_scope(scope* s)
    {
        current_scopes.push_back(s);
    }

    /**
     * Exit a scope.
     *
     * @param s The scope to leave. Has to be the last entered scope.
     */
    void exit_scope(scope* s)
    {
        if(current_scopes.size() == 0)
        {
            throw codegen_error("No scope to leave.");
        }

        if(current_scopes.back() != s)
        {
            throw codegen_error("Tried exiting wrong scope.");
        }

        current_scopes.pop_back();
    }

    /** Get the current scope. */
    scope* get_scope()
    {
        if(current_scopes.size() > 0)
        {
            return current_scopes.back();
        }

        return global_scope.get();
    }

    /*
     * Code generation.
     */

    /**
     * Generate a binary operator instruction.
     *
     * Reads two values from the stack and pushes the result of the operation to the stack.
     *
     * @param op The binary operation to execute.
     * @param op_type The type specifier for the operation.
     */
    void generate_binary_op(binary_op op, value op_type);

    /**
     * Generate an unconditional branch instruction.
     *
     * @param label The name of the jump target. This is the label of a basic_block.
     */
    void generate_branch(std::unique_ptr<label_argument> label);

    /**
     * Generate a compare instruction.
     *
     * Reads two values [value0, value1] from the stack and pushes the comparison result to the stack:
     * If value0==value1, 0 is pushed onto the stack. If value0<value1, -1 is pushed onto the stack.
     * If value0>value1, 1 is pushed onto the stack.
     */
    void generate_cmp();

    /**
     * Generate a conditional branch.
     *
     * Pops the top three values [condition, jmp_true, jmp_false] (all i32) off the
     * stack. If 'condition' is != 0, jumps to jmp_true, else to jmp_false.
     *
     * @param then_block The block to jump to if the condition is not false.
     * @param else_block The block to jump to if the condition is false.
     */
    void generate_cond_branch(basic_block* then_block, basic_block* else_block);

    /**
     * Load a constant value onto the stack.
     *
     * @param vt The value type.
     * @param val The value.
     */
    void generate_const(value vt, std::variant<int, float, std::string> val);

    /**
     * Statically or dynamically invoke a function. If the invokation
     * is dynamic, the function is loaded from the stack.
     *
     * @param name The function's name for statically invoked functions.
     */
    void generate_invoke(std::optional<std::unique_ptr<function_argument>> name = std::nullopt);

    /**
     * Load a variable onto the stack.
     *
     * @param arg The variable or function to load.
     */
    void generate_load(std::unique_ptr<argument> arg);

    /**
     * Load an element from a structure onto the stack.
     *
     * @note indices is a vector of `int`'s, since currently constant instruction arguments
     *      are `i32`, `f32` or `str`.
     *
     * @param indices Indices into a (possibly nested) structure.
     */
    void generate_load_element(std::vector<int> indices);

    /**
     * Return from a function.
     *
     * @param arg The returned type or std::nullopt.
     */
    void generate_ret(std::optional<value> arg = std::nullopt);

    /**
     * Store the top of the stack into a variable.
     *
     * @param arg The variable to store into.
     */
    void generate_store(std::unique_ptr<variable_argument> arg);

    /**
     * Store the top of the stack into a structure.
     *
     * @note indices is a vector of `int`'s, since currently constant instruction arguments
     *      are `i32`, `f32` or `str`.
     *
     * @param indices Indices into a (possibly nested) structure.
     */
    void generate_store_element(std::vector<int> indices);

    /*
     * Readable representation.
     */

    /** Generate a string representation. */
    std::string to_string() const
    {
        std::string buf;

        // strings.
        if(strings.size())
        {
            auto make_printable = [](const std::string& s) -> std::string
            {
                std::string str;

                // replace non-printable characters by their character codes.
                for(auto& c: s)
                {
                    if(!isalnum(c) && c != ' ')
                    {
                        str += fmt::format("\\x{:02x}", c);
                    }
                    else
                    {
                        str += c;
                    }
                }

                return str;
            };

            for(std::size_t i = 0; i < strings.size() - 1; ++i)
            {
                buf += fmt::format(".string @{} \"{}\"\n", i, make_printable(strings[i]));
            }
            buf += fmt::format(".string @{} \"{}\"", strings.size() - 1, make_printable(strings.back()));

            // don't append a newline if the string table is the only non-empty buffer.
            if(types.size() != 0 || funcs.size() != 0)
            {
                buf += "\n";
            }
        }

        // types.
        if(types.size() != 0)
        {
            for(std::size_t i = 0; i < types.size() - 1; ++i)
            {
                buf += fmt::format("{}\n", types[i]->to_string());
            }
            buf += fmt::format("{}", types.back()->to_string());

            // don't append a newline if there are no functions.
            if(funcs.size() != 0)
            {
                buf += "\n";
            }
        }

        // functions.
        if(funcs.size() != 0)
        {
            for(std::size_t i = 0; i < funcs.size() - 1; ++i)
            {
                buf += fmt::format("{}\n", funcs[i]->to_string());
            }
            buf += fmt::format("{}", funcs.back()->to_string());
        }

        return buf;
    }
};

/*
 * const_argument implementation.
 */

inline void const_argument::register_const(context& ctx)
{
    if(type->get_resolved_type() == "str")
    {
        auto type_str = static_cast<constant_str*>(type.get());
        type_str->set_constant_index(ctx.get_string(type_str->get_str()));
    }
}

/*
 * basic_block implementation.
 */

inline void basic_block::set_inserting_context(context* ctx)
{
    context* old_context = inserting_context;
    inserting_context = nullptr;

    // Clear the associated context's insertion point.
    if(old_context != nullptr && old_context->get_insertion_point() == this)
    {
        old_context->set_insertion_point(nullptr);
    }

    inserting_context = ctx;
    if(inserting_context != nullptr && inserting_context->get_insertion_point() != this)
    {
        inserting_context->set_insertion_point(this);
    }
}

/*
 * scope_guard implementation.
 */

inline scope_guard::scope_guard(context& ctx, scope* s)
: ctx{ctx}
, s{s}
{
    ctx.enter_scope(s);
}

inline scope_guard::~scope_guard()
{
    ctx.exit_scope(s);
}

}    // namespace slang::codegen
