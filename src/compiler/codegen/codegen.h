/**
 * slang - a simple scripting language.
 *
 * code generation.
 *
 * \author Felix Lubbe
 * \copyright Copyright (c) 2025
 * \license Distributed under the MIT software license (see accompanying LICENSE.txt).
 */

#pragma once

#include <algorithm>
#include <format>
#include <list>
#include <ranges>
#include <set>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

#include "archives/archive.h"
#include "archives/memory.h"
#include "compiler/constant.h"
#include "compiler/directive.h"
#include "compiler/lowering.h"
#include "compiler/name_utils.h"
#include "compiler/sema.h"
#include "compiler/type.h"
#include "shared/module.h"
#include "type.h"

/*
 * Forward declarations.
 */

namespace slang
{
class instruction_emitter;  /* emitter.h */
class export_table_builder; /* emitter.h */
}    // namespace slang

namespace slang::ast
{
class expression;       /* ast.h */
class macro_invocation; /* ast.h */
}    // namespace slang::ast

namespace slang::typing
{
class context; /* compiler/typing.h */
};    // namespace slang::typing

namespace slang::opt::cfg
{
class context; /* opt/cfg.h */
}    // namespace slang::opt::cfg

namespace slang::codegen
{

namespace ty = slang::typing;
namespace tl = slang::lowering;

/** Name resolution. */
struct name_resolver
{
    // Default destructor.
    virtual ~name_resolver() = default;

    /**
     * Return the name of a symbol.
     *
     * @param id The symbol id.
     * @returns Returns the symbol name.
     */
    [[nodiscard]]
    virtual std::string symbol_name(sema::symbol_id id) const = 0;

    /**
     * Return the name of a type.
     *
     * @param id The type id.
     * @returns Returns the type name.
     */
    [[nodiscard]]
    virtual std::string type_name(ty::type_id id) const = 0;

    /**
     * Return the name of a field.
     *
     * @param type_id The type id.
     * @param field_index The field index.
     * @returns Returns the field name.
     * @throws Throws a `codegen_error` if the field is not found.
     */
    [[nodiscard]]
    virtual std::string field_name(
      ty::type_id type_id,
      std::size_t field_index) const = 0;

    /**
     * Return the string value of a constant.
     *
     * @param id The constant id.
     * @returns Returns the constant as a string.
     * @throws Throws a `codegen_error` if the constant is not found.
     */
    [[nodiscard]]
    virtual std::string constant(
      const_::constant_id id) const = 0;
};

/** A code generation error. */
class codegen_error : public std::runtime_error
{
    using std::runtime_error::runtime_error;

public:
    /**
     * Construct a `codegen_error`.
     *
     * @param loc The error location in the source.
     * @param message The error message.
     */
    codegen_error(const slang::source_location& loc, const std::string& message);
};

/** A value. Values can be generated by evaluating an expression. */
class value
{
    /** The value's type */
    type ty;

    /** An optional symbol id for the value. */
    std::optional<sema::symbol_id> symbol_id;

public:
    /** Default constructors. */
    value() = default;
    value(const value&) = default;
    value(value&&) = default;

    /** Default destructor. */
    ~value() = default;

    /** Default assignments. */
    value& operator=(const value&) = default;
    value& operator=(value&&) = default;

    /**
     * Construct a value.
     *
     * @param type The value type.
     * @param symbol_id Optional name for this value.
     */
    value(type ty, std::optional<sema::symbol_id> symbol_id = std::nullopt)
    : ty{ty}
    , symbol_id{symbol_id}
    {
    }

    /** Copy the value. */
    [[nodiscard]]
    value copy_type() const
    {
        return {ty, symbol_id};
    }

    /**
     * Get the value as a readable string.
     *
     * @param resolver Optional name resolver.
     * @returns Returns a string representation of the value.
     */
    [[nodiscard]]
    std::string to_string(const name_resolver* resolver = nullptr) const;

    /** Get the value's type. */
    [[nodiscard]]
    type get_type() const
    {
        return ty;
    }

    /** Get the value's symbol id. */
    [[nodiscard]]
    const std::optional<sema::symbol_id>& get_symbol_id() const
    {
        return symbol_id;
    }

    /** Return whether the value has a symbol id. */
    [[nodiscard]]
    bool has_symbol_id() const
    {
        return symbol_id.has_value();
    }
};

/** A constant integer value. */
class constant_i32 : public value
{
    /** The integer. */
    int i;

public:
    /** Deleted and defaulted constructors. */
    constant_i32() = delete;
    constant_i32(const constant_i32&) = default;
    constant_i32(constant_i32&&) = default;

    /**
     * Construct a constant integer.
     *
     * @param i The integer.
     * @param id An optional symbol id.
     */
    constant_i32(
      int i,
      std::optional<sema::symbol_id> id = std::nullopt)
    : value{
        type{type_kind::i32},
        id}
    , i{i}
    {
    }

    /** Default destructor. */
    ~constant_i32() = default;

    /** Default assignments. */
    constant_i32& operator=(const constant_i32&) = default;
    constant_i32& operator=(constant_i32&&) = default;

    /** Get the integer. */
    [[nodiscard]]
    int get_int() const
    {
        return i;
    }
};

/** A constant floating point value. */
class constant_f32 : public value
{
    /** The floating point value. */
    float f;

public:
    /** Default constructors. */
    constant_f32() = delete;
    constant_f32(const constant_f32&) = default;
    constant_f32(constant_f32&&) = default;

    /**
     * Construct a constant float.
     *
     * @param f The float.
     * @param id An optional symbol id.
     */
    constant_f32(
      float f,
      std::optional<sema::symbol_id> id = std::nullopt)
    : value{
        type{type_kind::f32},
        id}
    , f{f}
    {
    }

    /** Default destructor. */
    ~constant_f32() = default;

    /** Default assignments. */
    constant_f32& operator=(const constant_f32&) = default;
    constant_f32& operator=(constant_f32&&) = default;

    /** Get the floating point value. */
    [[nodiscard]]
    float get_float() const
    {
        return f;
    }
};

/** A constant string value. */
class constant_str : public value
{
    /** The string id. */
    const_::constant_id const_id;

public:
    /** Default constructors. */
    constant_str() = delete;
    constant_str(const constant_str&) = default;
    constant_str(constant_str&&) = default;

    /**
     * Construct a constant string value.
     *
     * @param const_id The string id.
     * @param sym_id An optional symbol id.
     */
    constant_str(
      const_::constant_id const_id,
      std::optional<sema::symbol_id> sym_id = std::nullopt)
    : value{
        type{type_kind::str},
        sym_id}
    , const_id{const_id}
    {
    }

    /** Default destructor. */
    ~constant_str() = default;

    /** Default assignments. */
    constant_str& operator=(const constant_str&) = default;
    constant_str& operator=(constant_str&&) = default;

    /** Get a representation of the string in the for `@string_id`. */
    [[nodiscard]]
    std::string to_string() const
    {
        return std::format("@{}", const_id);
    }

    /** Return the string id. */
    [[nodiscard]]
    const_::constant_id get_constant_id() const
    {
        return const_id;
    }
};

/** An instruction argument. */
class argument
{
public:
    /** Default constructors. */
    argument() = default;
    argument(const argument&) = default;
    argument(argument&&) = default;

    /** Destructor. */
    virtual ~argument() = default;

    /** Default assignment. */
    argument& operator=(const argument&) = default;
    argument& operator=(argument&&) = default;

    /**
     * Get a string representation of the argument.
     *
     * @param resolver Optional name resolver.
     * @returns Returns a string representation fo the function.
     */
    [[nodiscard]]
    virtual std::string to_string(const name_resolver* resolver = nullptr) const = 0;
};

/**
 * A constant instruction argument.
 */
class const_argument : public argument
{
    /** The value. */
    std::unique_ptr<value> v;

public:
    /** Default and delered constructors. */
    const_argument() = default;
    const_argument(const const_argument&) = delete;
    const_argument(const_argument&&) = default;

    /**
     * Create a constant argument holding an `i32`.
     *
     * @param i The value to hold.
     * @param id An optional symbol id.
     */
    const_argument(
      int i,
      std::optional<sema::symbol_id> id)
    : v{std::make_unique<constant_i32>(i, id)}
    {
    }

    /**
     * Create a constant argument holding an `f32`.
     *
     * @param f The value to hold.
     * @param name An optional symbol id.
     */
    const_argument(
      float f,
      std::optional<sema::symbol_id> id)
    : v{std::make_unique<constant_f32>(f, id)}
    {
    }

    /**
     * Create a constant argument holding a `str`.
     *
     * @param s Constant id for the string.
     * @param name An optional symbol id.
     */
    const_argument(
      const_::constant_id s,
      std::optional<sema::symbol_id> id)
    : v{std::make_unique<constant_str>(s, id)}
    {
    }

    /** Default destructor. */
    ~const_argument() override = default;

    /** Default and deleted assignments. */
    const_argument& operator=(const const_argument&) = delete;
    const_argument& operator=(const_argument&&) = default;

    [[nodiscard]] std::string to_string(const name_resolver* resolver = nullptr) const override;

    [[nodiscard]]
    const value* get_value() const
    {
        return v.get();
    }
};

/**
 * Function argument.
 */
class function_argument : public argument
{
    /** Entry in the symbol table. */
    sema::symbol_id symbol_id;

public:
    /** Defaulted constructors. */
    function_argument() = default;
    function_argument(const function_argument&) = default;
    function_argument(function_argument&&) = default;

    /** Default destructor. */
    ~function_argument() override = default;

    /** Defaulted assignments. */
    function_argument& operator=(const function_argument&) = default;
    function_argument& operator=(function_argument&&) = default;

    /**
     * Create a function argument.
     *
     * @param symbol_id The function's symbol id.
     */
    function_argument(sema::symbol_id symbol_id)
    : symbol_id{symbol_id}
    {
    }

    [[nodiscard]]
    std::string to_string(const name_resolver* resolver = nullptr) const override
    {
        if(resolver != nullptr)
        {
            return std::format(
              "@{}",
              resolver->symbol_name(symbol_id));
        }

        return std::format(
          "<func#{}>",
          static_cast<int>(symbol_id.value));
    }

    [[nodiscard]]
    sema::symbol_id get_symbol_id() const
    {
        return symbol_id;
    }
};

/** Type argument. */
class type_argument : public argument
{
    /** The type. */
    type lowered_type;

public:
    /** Defaulted and deleted constructors. */
    type_argument() = delete;
    type_argument(const type_argument&) = default;
    type_argument(type_argument&&) = default;

    /** Default destructor. */
    ~type_argument() override = default;

    /** Default assignments. */
    type_argument& operator=(const type_argument&) = default;
    type_argument& operator=(type_argument&&) = default;

    /**
     * Create a type argument.
     *
     * @param lowered_type The lowered type.
     */
    explicit type_argument(type lowered_type)
    : lowered_type{lowered_type}
    {
    }

    [[nodiscard]]
    std::string to_string(const name_resolver* resolver = nullptr) const override
    {
        // try to resolve type id.
        if(resolver
           && lowered_type.get_type_id().has_value())
        {
            return std::format(
              "{}",
              resolver->type_name(lowered_type.get_type_id().value()));
        }

        // if the type id exists, append it.
        if(lowered_type.get_type_kind() == type_kind::ref
           && lowered_type.get_type_id().has_value())
        {
            return std::format(
              "{}<type#{}>",
              ::slang::codegen::to_string(lowered_type.get_type_kind()),
              lowered_type.get_type_id().value());
        }

        return lowered_type.to_string();
    }

    /** Return the lowered type. */
    [[nodiscard]]
    type get_lowered_type() const
    {
        return lowered_type;
    }
};

/** A variable instruction argument. */
class variable_argument : public argument
{
    /** The variable. */
    std::unique_ptr<value> var;

public:
    /** Defaulted and deleted constructors. */
    variable_argument() = delete;
    variable_argument(const variable_argument&) = delete;
    variable_argument(variable_argument&&) = default;

    /** Default destructor. */
    ~variable_argument() override = default;

    /** Default assignments. */
    variable_argument& operator=(const variable_argument&) = delete;
    variable_argument& operator=(variable_argument&&) = default;

    /**
     * Create a variable argument.
     *
     * @param v The variable.
     */
    explicit variable_argument(std::unique_ptr<value> v)
    : var{std::move(v)}
    {
    }

    [[nodiscard]]
    std::string to_string(const name_resolver* resolver = nullptr) const override
    {
        return var->to_string(resolver);
    }

    [[nodiscard]]
    const value* get_value() const
    {
        return var.get();
    }
};

/** A label argument for jump instructions. */
class label_argument : public argument
{
    /** The label. */
    std::string label;

public:
    /** Default constructors. */
    label_argument() = default;
    label_argument(const label_argument&) = default;
    label_argument(label_argument&&) = default;

    /** Default destructor. */
    ~label_argument() override = default;

    /** Default assignments. */
    label_argument& operator=(const label_argument&) = default;
    label_argument& operator=(label_argument&&) = default;

    /**
     * Construct a label.
     *
     * @param label The label.
     */
    explicit label_argument(std::string label)
    : label{std::move(label)}
    {
    }

    /** Return the label. */
    [[nodiscard]]
    const std::string& get_label() const
    {
        return label;
    }

    [[nodiscard]]
    std::string to_string([[maybe_unused]] const name_resolver* resolver = nullptr) const override
    {
        return std::format("%{}", label);
    }
};

/** Stack value argument. */
class stack_value_argument : public argument
{
    /** The stack value. */
    stack_value value;

public:
    /** Defaulted and deleted constructors. */
    stack_value_argument() = delete;
    stack_value_argument(const stack_value_argument&) = default;
    stack_value_argument(stack_value_argument&&) = default;

    /** Default destructor. */
    ~stack_value_argument() override = default;

    /** Default assignments. */
    stack_value_argument& operator=(const stack_value_argument&) = default;
    stack_value_argument& operator=(stack_value_argument&&) = default;

    /**
     * Create a stack value argument.
     *
     * @param value The stack value.
     */
    explicit stack_value_argument(stack_value value)
    : value{value}
    {
    }

    [[nodiscard]]
    std::string to_string(
      [[maybe_unused]] const name_resolver* resolver = nullptr)
      const override
    {
        return ::slang::to_string(value);
    }

    /** Return the stack value. */
    [[nodiscard]]
    stack_value get_value() const
    {
        return value;
    }
};

/** Type casts. */
enum class type_cast : std::uint8_t
{
    i32_to_f32, /* i32 to f32 */
    f32_to_i32, /* f32 to i32 */
};

/**
 * Return a string representation of the type cast.
 *
 * @param tc The type cast.
 * @returns A string representation of the type cast.
 */
std::string to_string(type_cast tc);

/** A type cast argument. */
class cast_argument : public argument
{
    /** The type cast. */
    type_cast cast;

    /** Result type id. */
    value result_value;

    /** Result type of the cast. */
    type_kind result_type;

public:
    /** Default constructors. */
    cast_argument() = default;
    cast_argument(const cast_argument&) = delete;
    cast_argument(cast_argument&&) = default;

    /** Default destructor. */
    ~cast_argument() override = default;

    /** Default assignments. */
    cast_argument& operator=(const cast_argument&) = delete;
    cast_argument& operator=(cast_argument&&) = default;

    /**
     * Construct a type cast.
     *
     * @param cast The cast type.
     */
    cast_argument(
      type_cast cast)
    : cast{cast}
    {
        if(cast == type_cast::i32_to_f32)
        {
            result_type = type_kind::f32;
        }
        else if(cast == type_cast::f32_to_i32)
        {
            result_type = type_kind::i32;
        }
        else
        {
            throw codegen_error("Unknown cast type.");
        }

        result_value = value{result_type};
    }

    /** Return the cast type. */
    [[nodiscard]]
    type_cast get_cast() const
    {
        return cast;
    }

    [[nodiscard]]
    std::string to_string([[maybe_unused]] const name_resolver* resolver = nullptr) const override
    {
        return std::format("{}", ::slang::codegen::to_string(cast));
    }

    [[nodiscard]]
    const value* get_value() const    // FIXME Remove / replace by get_target_type
    {
        return &result_value;
    }
};

/** Field access argument. */
class field_access_argument : public argument
{
    /** The struct information. */
    type struct_type;

    /** Field index. */
    std::size_t field_index;

public:
    /** Defaulted and deleted constructors. */
    field_access_argument() = default;
    field_access_argument(const field_access_argument&) = default;
    field_access_argument(field_access_argument&&) = default;

    /** Default assignments. */
    field_access_argument& operator=(const field_access_argument&) = default;
    field_access_argument& operator=(field_access_argument&&) = default;

    /** Default destructor. */
    ~field_access_argument() override = default;

    /**
     * Construct a field access.
     *
     * @param struct_type Type information for the struct.
     * @param field_index Index of the field.
     */
    field_access_argument(
      type struct_type,
      std::size_t field_index)
    : argument()
    , struct_type{struct_type}
    , field_index{field_index}
    {
    }

    /** Return the struct's type id. */
    [[nodiscard]]
    ty::type_id get_struct_type_id() const
    {
        return struct_type.get_type_id().value();
    }

    /** Return the field index. */
    [[nodiscard]]
    std::size_t get_field_index() const
    {
        return field_index;
    }

    [[nodiscard]]
    std::string to_string(const name_resolver* resolver = nullptr) const override
    {
        if(!struct_type.get_type_id().has_value())
        {
            throw codegen_error("Type has no id.");
        }

        if(resolver != nullptr
           && struct_type.get_type_id().has_value())
        {
            auto type_id = struct_type.get_type_id().value();

            return std::format(
              "%{}.{}",
              resolver->type_name(type_id),
              resolver->field_name(type_id, field_index));
        }

        return std::format(
          "<type#{}>.<field#{}>",
          struct_type.get_type_id().value(),
          field_index);
    }
};

/**
 * Instruction base class.
 */
class instruction
{
    /** The instruction name. */
    std::string name;

    /** The instruction's arguments. */
    std::vector<std::unique_ptr<argument>> args;

public:
    /** Default constructors. */
    instruction() = default;
    instruction(const instruction&) = default;
    instruction(instruction&&) = default;

    /** Destructor. */
    ~instruction() = default;

    /** Default assignments. */
    instruction& operator=(const instruction&) = default;
    instruction& operator=(instruction&&) = default;

    /**
     * Construct an instruction without arguments.
     *
     * @param name The instruction's opcode name.
     */
    explicit instruction(std::string name)
    : name{std::move(name)}
    {
    }

    /**
     * Construct an instruction with arguments.
     *
     * @param name The instruction's opcode name.
     * @param args The instruction's arguments.
     */
    instruction(std::string name, std::vector<std::unique_ptr<argument>> args)
    : name{std::move(name)}
    , args{std::move(args)}
    {
    }

    /** Returns whether the instruction is branching. */
    [[nodiscard]]
    bool is_branching() const
    {
        return name == "jmp" || name == "jnz";
    }

    /** Returns whether the instruction is a return instruction. */
    [[nodiscard]]
    bool is_return() const
    {
        return name == "ret";
    }

    /** Get the instruction name. */
    [[nodiscard]]
    const std::string& get_name() const
    {
        return name;
    }

    /** Get the instruction's arguments. */
    [[nodiscard]]
    const std::vector<std::unique_ptr<argument>>& get_args() const
    {
        return args;
    }

    /**
     * Get instruction representation as string.
     *
     * @param resolver Optional name resolver.
     * @returns Returns a string representation of the instruction.
     */
    [[nodiscard]]
    std::string to_string(const name_resolver* resolver = nullptr) const;
};

/**
 * A block that has a single named entry point, a single exit point and
 * no branching.
 */
class basic_block
{
    friend class context;

    /** The block's entry label. */
    std::string label;

    /** The instructions. */
    std::vector<std::unique_ptr<instruction>> instrs;

    /** The associated inserting context (if any). */
    class context* inserting_context{nullptr};

    /**
     * Set a new context for inserting instructions.
     * Pass nullptr to clear the context.
     *
     * @param ctx The new context or nullptr.
     */
    void set_inserting_context(class context* ctx);

    /**
     * Create a basic_block.
     *
     * @param label The block's label.
     */
    explicit basic_block(std::string label)
    : label{std::move(label)}
    , instrs{}
    {
    }

public:
    /** Default constructors. */
    basic_block() = delete;
    basic_block(const basic_block&) = delete;
    basic_block(basic_block&&) = delete;

    /** Destructor. */
    ~basic_block()
    {
        // clear references to this block.
        set_inserting_context(nullptr);
    }

    /** Default assignments. */
    basic_block& operator=(const basic_block&) = delete;
    basic_block& operator=(basic_block&&) = delete;

    /**
     * Add a non-branching instruction.
     *
     * Throws a `codegen_error` if the instruction is branching.
     *
     * @param instr The instruction.
     */
    void add_instruction(std::unique_ptr<instruction> instr)
    {
        instrs.emplace_back(std::move(instr));
    }

    /**
     * Get a string representation of the basic block.
     *
     * @param resolver Optional name resolver.
     * @returns Returns a string representation of the basic block.
     */
    [[nodiscard]]
    std::string to_string(const name_resolver* resolver = nullptr) const;

    /** Get the inserting context. May return nullptr. */
    [[nodiscard]]
    class context* get_inserting_context() const
    {
        return inserting_context;
    }

    /** Get the block label. */
    [[nodiscard]]
    std::string get_label() const
    {
        return label;
    }

    /** Return whether this block ends with a return statement. */
    [[nodiscard]]
    bool ends_with_return() const
    {
        return !instrs.empty() && instrs.back()->is_return();
    }

    /** Return whether this block ends with a branch statement. */
    [[nodiscard]]
    bool ends_with_branch() const
    {
        return !instrs.empty() && instrs.back()->is_branching();
    }

    /** Whether this block is terminated, i.e., ending with a branch or return. */
    [[nodiscard]]
    bool is_terminated() const
    {
        return ends_with_return() || ends_with_branch();
    }

    /**
     * Return whether this block is valid.
     *
     * A block is valid if it contains a single return or branch instruction,
     * located at its end.
     */
    [[nodiscard]]
    bool is_valid() const;

    /** Get the block's instructions. */
    [[nodiscard]]
    const std::vector<std::unique_ptr<instruction>>& get_instructions() const
    {
        return instrs;
    }

    /** Get the block's instructions. */
    std::vector<std::unique_ptr<instruction>>& get_instructions()
    {
        return instrs;
    }

    /**
     * Create a `basic_block`.
     *
     * @param ctx The context for the new block.
     * @param name The block name.
     * @return Returns a new `basic_block`.
     */
    static basic_block* create(class context& ctx, std::string name);
};

/**
 * A guard that signals function entry and exit.
 */
class function_guard
{
    /** The associated context. */
    context& ctx;

public:
    /** No default constructor. */
    function_guard() = delete;

    /** Deleted copy and move constructors. */
    function_guard(const function_guard&) = delete;
    function_guard(function_guard&&) = delete;

    /**
     * Construct a function guard.
     *
     * @param ctx The associated context.
     * @param fn The function.
     */
    function_guard(context& ctx, class function* fn);

    /** Destructor. */
    ~function_guard();

    /** Deleted assignments.*/
    function_guard& operator=(const function_guard&) = delete;
    function_guard& operator=(function_guard&&) = delete;
};

/** A function.*/
class function
{
    /** The function's name. */
    std::string name;

    /** Whether this is a native function. */
    bool native;

    /** Import library name for native functions. */
    std::string import_library;

    /** The function's return type. */
    type return_type;

    /** The function's arguments. */
    std::vector<
      std::pair<
        sema::symbol_id,
        type>>
      args;

    /** Locals. */
    std::vector<
      std::pair<
        sema::symbol_id,
        type>>
      locals;

    /** Function instructions. */
    std::list<basic_block*> instr_blocks;

public:
    /** Constructors. */
    function() = delete;
    function(const function&) = delete;
    function(function&&) = default;

    /**
     * Construct a function from name, return type and argument list.
     *
     * @param name The function's name.
     * @param return_type The function's return type.
     * @param args The function's argument list.
     */
    function(
      std::string name,
      type return_type,
      std::vector<
        std::pair<
          sema::symbol_id,
          type>>
        args)
    : name{name}
    , native{false}
    , return_type{std::move(return_type)}
    , args{std::move(args)}
    {
    }

    /**
     * Construct a native function from import library name and function name.
     *
     * @param import_library The import library's name.
     * @param name The function's name.
     * @param return_type The function's return type.
     * @param args The function's argument list.
     */
    function(
      std::string import_library,
      std::string name,
      type return_type,
      std::vector<
        std::pair<
          sema::symbol_id,
          type>>
        args)
    : name{name}
    , native{true}
    , import_library{import_library}
    , return_type{std::move(return_type)}
    , args{std::move(args)}
    {
    }

    /** Destructor. */
    ~function() = default;

    /** Assignments. */
    function& operator=(const function&) = delete;
    function& operator=(function&&) = delete;

    /** Get the function's name. */
    [[nodiscard]]
    const std::string& get_name() const
    {
        return name;
    }

    /**
     * Add a local variable.
     *
     * @param id The local's symbol id.
     * @param ty The local's type.
     */
    void add_local(
      sema::symbol_id id,
      type ty);

    /**
     * Append an instruction block.
     *
     * @param block The instruction block to append.
     */
    void append_basic_block(basic_block* block)
    {
        instr_blocks.push_back(block);
    }

    /**
     * Remove an instruction block by label.
     *
     * @note This unlinks the block, without freeing its memory (managed by the codegen context).
     * @note Removing a block invalidates iterators and references for that basic block.
     *
     * @throws Throws a `codegen_error` if the label could not be found.
     *
     * @param label The block's label.
     * @returns A pointer to the block.
     */
    basic_block* remove_basic_block(const std::string& label);

    /** Return whether the function ends with a return statement. */
    [[nodiscard]]
    bool ends_with_return() const
    {
        return !instr_blocks.empty() && instr_blocks.back()->ends_with_return();
    }

    /** Returns the function's signature as a pair `(return_type, arg_types)`. */
    [[nodiscard]]
    std::pair<type, std::vector<type>> get_signature() const
    {
        std::vector<type> arg_types =
          args
          | std::views::transform(
            [](const auto& arg) -> type
            {
                return arg.second;
            })
          | std::ranges::to<std::vector>();
        return {return_type, std::move(arg_types)};
    }

    /** Return whether this is a native function. */
    [[nodiscard]]
    bool is_native() const
    {
        return native;
    }

    /**
     * Return the import library for a native function.
     *
     * @throws Throws a `codegen_error` if this is not a native function.
     *
     * @returns The import library name.
     */
    [[nodiscard]]
    std::string get_import_library() const
    {
        if(!native)
        {
            throw codegen_error(
              std::format(
                "Cannot get import library for function '{}', as it was not declared as native.",
                get_name()));
        }

        return import_library;
    }

    /** Return the function's arguments. */
    [[nodiscard]]
    const std::vector<
      std::pair<
        sema::symbol_id,
        type>>
      get_args() const
    {
        return args;
    }

    /** Return the function's locals. */
    [[nodiscard]]
    const std::vector<
      std::pair<
        sema::symbol_id,
        type>>
      get_locals() const
    {
        return locals;
    }

    /**
     * Return the index of an argument or local.
     *
     * @param id The symbol id of the argument or local.
     * @returns Returns the index.
     * @throws Throws a `codegen_error` if the given symbol id was not found.
     */
    std::size_t get_index(sema::symbol_id id) const;

    /**
     * Return the basic blocks.
     *
     * @returns The function's basic blocks.
     */
    [[nodiscard]]
    const std::list<basic_block*>& get_basic_blocks() const
    {
        return instr_blocks;
    }

    /**
     * String representation of the function.
     *
     * @param resolver Optional name resolver.
     * @returns Returns a string representation of the function.
     */
    [[nodiscard]]
    std::string to_string(const name_resolver* resolver = nullptr) const;
};

/**
 * A binary operation. Reads two alike values from the stack and puts
 * a value of the same type onto the stack.
 */
enum class binary_op
{
    op_mul,           /** a * b */
    op_div,           /** a / b */
    op_mod,           /** a % b */
    op_add,           /** a + b */
    op_sub,           /** a - b */
    op_shl,           /** a << b */
    op_shr,           /** a >> b */
    op_less,          /** a < b */
    op_less_equal,    /** a <= b */
    op_greater,       /** a > b */
    op_greater_equal, /** a >= b */
    op_equal,         /** a == b */
    op_not_equal,     /** a != b */
    op_and,           /** a & b */
    op_xor,           /** a ^ b */
    op_or,            /** a | b */
    op_logical_and,   /** a && b */
    op_logical_or,    /** a || b */
};

/**
 * Return a string representation of a binary operator.
 *
 * @param op The binary operator.
 * @returns A string representation of the operator.
 */
std::string to_string(binary_op op);

/** An imported symbol. */
struct imported_symbol
{
    /** Symbol type. */
    module_::symbol_type type;

    /** Symbol name. */
    std::string name;

    /** The import path of the module. */
    std::string import_path;

    /** Default constructors. */
    imported_symbol() = default;
    imported_symbol(const imported_symbol&) = default;
    imported_symbol(imported_symbol&&) = default;

    /** Default assignments. */
    imported_symbol& operator=(const imported_symbol&) = default;
    imported_symbol& operator=(imported_symbol&&) = default;

    /**
     * Construct an `imported_symbol`.
     *
     * @param type The symbol's type.
     * @param name The symbol's name.
     * @param import_path Path of the module the symbol is imported from.
     */
    imported_symbol(module_::symbol_type type, std::string name, std::string import_path)
    : type{type}
    , name{std::move(name)}
    , import_path{std::move(import_path)}
    {
    }
};

/** Constant table entry. */
struct constant_table_entry : public module_::constant_table_entry
{
    /** Optional import path. */
    std::optional<std::string> import_path = std::nullopt;

    /** Optional name. */
    std::optional<std::string> name = std::nullopt;

    /** Whether to export the constant. */
    bool add_to_exports = false;

    /**
     * Construct a constant table entry.
     *
     * @throws Throws a `codegen_error` if `add_to_exports` is `true` and no `name` was set.
     *
     * @param type The constant type.
     * @param value The constant's value.
     * @param import_path Optional import path.
     * @param name Optional name for the constant.
     * @param add_to_exports Whether to export the constant. Defaults to `false`.
     */
    template<typename T>
    constant_table_entry(
      module_::constant_type type,
      T value,
      std::optional<std::string> import_path = std::nullopt,
      std::optional<std::string> name = std::nullopt,
      bool add_to_exports = false)
    : module_::constant_table_entry{type, std::move(value)}
    , import_path{std::move(import_path)}
    , name{std::move(name)}
    , add_to_exports{add_to_exports}
    {
        if(add_to_exports && !this->name.has_value())
        {
            throw codegen_error("Cannot export constant without a name.");
        }
    }
};

/** Code generator context. */
class context
{
    // FIXME Too many friends.
    friend class slang::instruction_emitter;
    friend class slang::export_table_builder;
    friend class slang::opt::cfg::context;
    friend class basic_block;

    /** Semantic environment. */
    sema::env& sema_env;

    /** Constant environment. */
    const_::env& const_env;

    /** Type lowering context. */
    tl::context& lowering_ctx;

    /** List of functions. */
    std::vector<std::unique_ptr<function>> funcs;

    /** The currently compiled function, or `nullptr`. */
    function* current_function{nullptr};

    /** Macro invocation id (to make identifiers unique for each invocation). */
    std::size_t macro_invocation_id{0};

    /** The basic blocks for `break` and `continue` statements. */
    std::vector<std::pair<basic_block*, basic_block*>> basic_block_brk_cnt;

    /** List of basic blocks. */
    std::vector<std::unique_ptr<basic_block>> basic_blocks;

    /** A label counter for unique label generation. */
    std::size_t label_count = 0;

    /** Current instruction insertion point. */
    basic_block* insertion_point{nullptr};

    /** Holds the array type when declaring an array. */
    std::optional<value> array_type = std::nullopt;

protected:
    /**
     * Check that the insertion point is not null.
     *
     * @throws Throws a `codegen_error` if the insertion point is null.
     */
    void validate_insertion_point() const
    {
        if(!insertion_point)
        {
            throw codegen_error("Invalid insertion point (nullptr).");
        }
    }

public:
    /** Whether to evaluate constant subexpressions during code generation. */
    bool evaluate_constant_subexpressions{true};

public:
    /** Constructors. */
    context() = delete;
    context(const context&) = delete;
    context(context&&) = default;

    /**
     * Construct a code generation context.
     *
     * @param sema_env The semantic environment.
     * @param const_env The constant evaluation environment.
     * @param lowering_ctx Type lowering context.
     */
    context(
      sema::env& sema_env,
      const_::env& const_env,
      tl::context& lowering_ctx)
    : sema_env{sema_env}
    , const_env{const_env}
    , lowering_ctx{lowering_ctx}
    {
    }

    /** Destructor. */
    ~context()
    {
        try
        {
            // FIXME This could throw a `codegen_error`.
            set_insertion_point(nullptr);
        }
        catch(const codegen_error&)
        {
            /* ignore */
        }
    }

    /** Assignments. */
    context& operator=(const context&) = delete;
    context& operator=(context&&) = delete;

    /**
     * Lower a front-end type to a back-end type.
     *
     * @param id The front-end type id.
     * @returns Returns the lowered back-end type.
     */
    type lower(ty::type_id id)
    {
        return lowering_ctx.lower(id);
    }

    /**
     * Dereference a type. Needs to have the front-end type id set.
     *
     * @param reference_type The type to dereference.
     * @param Returns the dereferences type.
     */
    type deref(const type& reference_type)
    {
        return lowering_ctx.deref(reference_type);
    }

    /** Get the type lowering context. */
    const tl::context& get_lowering_context() const
    {
        return lowering_ctx;
    }

    /**
     * Intern a string constant.
     *
     * @param s The string.
     * @returns Returns an index for the string.
     */
    const_::constant_id intern(std::string s)
    {
        return const_env.intern(std::move(s));
    }

    /** Get the constant environment. */
    const const_::env& get_const_env() const
    {
        return const_env;
    }

    /** Get semantic environment. */
    const sema::env& get_sema_env() const
    {
        return sema_env;
    }

    /**
     * Add a function definition.
     *
     * Throws a `codegen_error` if the function name already exists.
     *
     * @param name The function's name.
     * @param return_type The function's return type.
     * @param args The function's arguments.
     * @returns A representation of the function.
     */
    [[nodiscard]]
    function* create_function(
      std::string name,
      type return_type,
      std::vector<
        std::pair<
          sema::symbol_id,
          type>>
        args);

    /**
     * Add a function with a native implementation in a library.
     *
     * Throws a `codegen_error` if the function name already exists.
     *
     * @param lib_name Name of the library the function should be imported from.
     * @param name The function's name.
     * @param return_type The function's return type.
     * @param args The function's arguments.
     */
    void create_native_function(
      std::string lib_name,
      std::string name,
      type return_type,
      std::vector<
        std::pair<
          sema::symbol_id,
          type>>
        args);

    /** Generate a unique macro invocation id. */
    [[nodiscard]]
    std::size_t generate_macro_invocation_id();

    /**
     * Set instruction insertion point.
     *
     * @param ip The insertion point for instructions.
     */
    void set_insertion_point(basic_block* ip);

    /**
     * Get the current insertion point.
     *
     * @param validate Whether to throw a `codegen_error` if the insertion point is `nullptr`.
     *                 Defaults to `false`.
     * @return Returns the current insertion point.
     */
    [[nodiscard]]
    basic_block* get_insertion_point(bool validate = false) const
    {
        if(validate && insertion_point == nullptr)
        {
            throw codegen_error("Invalid insertion point.");
        }
        return insertion_point;
    }

    /**
     * Enter a function. Only one function can be entered at a time.
     *
     * @param fn The function.
     */
    void enter_function(function* fn)
    {
        if(current_function != nullptr)
        {
            throw codegen_error("Nested function definition.");
        }

        if(fn == nullptr)
        {
            throw codegen_error("No function specified.");
        }

        current_function = fn;
    }

    /** Exit a function. */
    void exit_function()
    {
        if(current_function == nullptr)
        {
            throw codegen_error("No function to exit.");
        }

        current_function = nullptr;
    }

    /**
     * Return the current function, or nullptr.
     *
     * @param validate If set to `true`, the function will throw a `codegen_error` instead of returning `nullptr`.
     *                 Defaults to `false`.
     * @return Returns the current function.
     */
    [[nodiscard]]
    function* get_current_function(bool validate = false)
    {
        if(validate && current_function == nullptr)
        {
            throw codegen_error("No current function.");
        }
        return current_function;
    }

    /**
     * Set the array type when an array is declared.
     *
     * @param v The array type.
     * @throws Throws a `codegen_error` if the array type was already set.
     */
    void set_array_type(value v)
    {
        if(array_type.has_value())
        {
            throw codegen_error("Cannot set array type since it is already set.");
        }
        array_type = v;
    }

    /**
     * Return the array type.
     *
     * @return The array type.
     * @throws Throws a `codegen_error` if no array was declared.
     */
    [[nodiscard]]
    value get_array_type() const
    {
        if(!array_type.has_value())
        {
            throw codegen_error("Cannot get array type since no array was declared.");
        }
        return *array_type;
    }

    /**
     * Clear the array type. Needs to be called when array declaration is completed.
     *
     * @throws Throws a `codegen_error` if no array was declared.
     */
    void clear_array_type()
    {
        if(!array_type.has_value())
        {
            throw codegen_error("Cannot clear array type since no array was declared.");
        }
        array_type.reset();
    }

    /**
     * Push a new `break`-`continue` `basic_block` pair.
     *
     * @param brk_cnt The `break`-`continue` pair.
     */
    void push_break_continue(std::pair<basic_block*, basic_block*> brk_cnt)
    {
        basic_block_brk_cnt.push_back(std::move(brk_cnt));
    }

    /**
     * Pop a `break`-`continue` `basic_block` pair.
     *
     * @param loc An optional token location. If provided, this is used in error reporting.
     * @throws Throws a `codegen_error` if the stack is empty.
     */
    void pop_break_continue(std::optional<source_location> loc = std::nullopt)
    {
        if(basic_block_brk_cnt.empty())
        {
            if(loc.has_value())
            {
                throw codegen_error(*loc, "Encountered break or continue statement outside of loop.");
            }
            else
            {
                throw codegen_error("Encountered break or continue statement outside of loop.");
            }
        }
        basic_block_brk_cnt.pop_back();
    }

    /**
     * Return the top `break`-`continue` `basic_block` pair.
     *
     * @param loc An optional token location. If provided, this is used in error reporting.
     * @throws Throws a `codegen_error` if the stack is empty.
     */
    [[nodiscard]]
    std::pair<basic_block*, basic_block*> top_break_continue(std::optional<source_location> loc = std::nullopt)
    {
        if(basic_block_brk_cnt.empty())
        {
            if(loc.has_value())
            {
                throw codegen_error(*loc, "Encountered break or continue statement outside of loop.");
            }
            else
            {
                throw codegen_error("Encountered break or continue statement outside of loop.");
            }
        }
        return basic_block_brk_cnt.back();
    }

    /** Get `break`-`continue` stack size. */
    [[nodiscard]]
    std::size_t get_break_continue_stack_size() const
    {
        return basic_block_brk_cnt.size();
    }

    /*
     * Code generation.
     */

    /**
     * Generate an `arraylength` instruction.
     *
     * Reads an array reference from the stack and pushes its length as an `i32` onto the stack.
     */
    void generate_arraylength();

    /**
     * Generate a binary operator instruction.
     *
     * Reads two values from the stack and pushes the result of the operation to the stack.
     *
     * @param op The binary operation to execute.
     * @param op_type The type specifier for the operation.
     */
    void generate_binary_op(binary_op op, const type& op_type);

    /**
     * Generate an unconditional branch instruction.
     *
     * @param block The block to jump to. Cannot be a `nullptr`.
     */
    void generate_branch(basic_block* block);

    /**
     * Generate a type cast.
     *
     * Reads a value of a type from the stack and pushes the same value as another type back to the stack.
     *
     * @param tc The type cast to do.
     */
    void generate_cast(type_cast tc);

    /**
     * Generate a `checkcast` instruction for type cast validation.
     *
     * Reads an address off the stack, validates that it is of a given type, and writes it back to the stack.
     * If the check fails, an `interpreter_error` is thrown`.
     *
     * @param tc The type to check for.
     */
    void generate_checkcast(type target_type);

    /**
     * Generate a conditional branch.
     *
     * Pops 'condition off the stack. If 'condition' is != 0, jumps to `then_block`, else to `else_block`.
     *
     * @param then_block The block to jump to if the condition is not false. Cannot be a `nullptr`.
     * @param else_block The block to jump to if the condition is false. Can be a `nullptr`.
     * @throws Throws a `codegen_error` if `then_block` is `nullptr`.
     */
    void generate_cond_branch(basic_block* then_block, basic_block* else_block);

    /**
     * Load a constant value onto the stack.
     *
     * @param vt The value type.
     * @param val The value.
     */
    void generate_const(
      const type& vt,
      std::variant<int, float, const_::constant_id> val);

    /** Load 'null' onto the stack. */
    void generate_const_null();

    /**
     * Duplicate the top stack value.
     *
     * @param vt The value's type.
     */
    void generate_dup(type vt);

    /**
     * Duplicate the top stack value and insert it two values down.
     *
     * @param vt The value's type.
     * @param skip_type The value to skip on the stack before insertion.
     */
    void generate_dup_x1(type vt, type skip_type);

    /**
     * Duplicate the top stack value and insert it three values down.
     *
     * @param vt The value's type.
     * @param skip_type1 The first value to skip on the stack before insertion.
     * @param skip_type2 The second value to skip on the stack before insertion.
     */
    void generate_dup_x2(type vt, type skip_type1, type skip_type2);

    /**
     * Load a field of a struct instance onto the stack.
     *
     * @param arg The field access details.
     */
    void generate_get_field(std::unique_ptr<field_access_argument> arg);

    /**
     * Statically invoke a function.
     *
     * @param f The function to call.
     */
    void generate_invoke(function_argument f);

    /** Dynamically invoke a function that was pushed on the stack. */
    void generate_invoke_dynamic();

    /**
     * Load a variable onto the stack.
     *
     * @param v The variable to load.
     */
    void generate_load(variable_argument v);

    /**
     * Load an array element onto the stack.
     *
     * @param t The variable type of the array.
     */
    void generate_load_element(type_argument t);

    /**
     * Create a new instance of a type.
     *
     * @param t The type.
     */
    void generate_new(const type& t);

    /**
     * Create a new array of a given built-in type.
     *
     * @param t The array type.
     */
    void generate_newarray(const type& t);

    /**
     * Create a new array of a given custom type.
     *
     * @param t The array type.
     */
    void generate_anewarray(const type& t);

    /**
     * Pop a value from the stack.
     *
     * @param t The value type.
     */
    void generate_pop(const type& vt);

    /**
     * Return from a function.
     *
     * @param arg The returned type or std::nullopt.
     */
    void generate_ret(std::optional<type> arg = std::nullopt);

    /**
     * Store the top of the stack into a field of a struct instance on the stack.
     *
     * @param arg The field access details.
     */
    void generate_set_field(std::unique_ptr<field_access_argument> arg);

    /**
     * Store the top of the stack into a variable.
     *
     * @param arg The variable to store into.
     */
    void generate_store(variable_argument v);

    /**
     * Store the top of the stack into an array element.
     *
     * @param t The variable type of the array.
     */
    void generate_store_element(type_argument t);

    /**
     * Generate a label to be used by branches and jump instructions.
     *
     * @returns A unique label identifier.
     */
    [[nodiscard]]
    std::string generate_label();

    /*
     * Readable representation.
     */

    /**
     * Generate a string representation.
     *
     * @param resolver An optional name resolver.
     * @returns Returns a readable string representation of the context.
     */
    [[nodiscard]]
    std::string to_string(const name_resolver* resolver = nullptr) const;
};

/*
 * basic_block implementation.
 */

inline void basic_block::set_inserting_context(context* ctx)
{
    context* old_context = inserting_context;
    inserting_context = nullptr;

    // Clear the associated context's insertion point.
    if(old_context != nullptr && old_context->get_insertion_point() == this)
    {
        old_context->set_insertion_point(nullptr);
    }

    inserting_context = ctx;
    if(inserting_context != nullptr && inserting_context->get_insertion_point() != this)
    {
        inserting_context->set_insertion_point(this);
    }
}

inline basic_block* basic_block::create(context& ctx, std::string name)
{
    return ctx.basic_blocks.emplace_back(new basic_block(name)).get();
}

/*
 * function_guard implementation.
 */

inline function_guard::function_guard(context& ctx, function* fn)
: ctx{ctx}
{
    ctx.enter_function(fn);
}

inline function_guard::~function_guard()
{
    ctx.exit_function();
}

}    // namespace slang::codegen
